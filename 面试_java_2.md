# 哪些情况下的对象会被垃圾回收机制处理掉？

实际回收的时机由 JVM 来确定的或者是手动调用 system.gc 的时候。根据不同的算法回收的时机也不一样。

垃圾回收算法有
- 引用计数法

  引用计数算法，就是标记当前对象被引用的次数，每被引用一次就 +1，当引用超过生命周期或者被设置新值时就 -1，当计数器为0时就回收。这种算法的好处是执行以及回收很及时。缺点是无法检测出循环引用。

- tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)

  根搜索算法，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

  在扫描过程中对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。

- compacting算法 或 标记-整理算法

  标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。

- copying算法(Compacting Collector)

  该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。

- generation算法(Generational Collector)

  分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。

  - 年轻代

    年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
    新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。一些比较大的对象会生成到老年代中。
    新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)

  - 老年代

    在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。
    
  - 持久代

    用于存放静态文件，如Java类、方法等。

GC触发的机制：

  - Scavenge GC（Minor GC）

    一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

  - Full GC

    对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

    - 年老代（Tenured）被写满
    - 持久代（Perm）被写满 
    - System.gc()被显示调用 
    - 上一次GC之后Heap的各域分配策略动态变化

[参考](http://www.cnblogs.com/sunniest/p/4575144.html)
[参考](https://www.zhihu.com/question/35164211)
[参考](http://icyfenix.iteye.com/blog/715301)

# 常见编码方式

GBK 
ISO-8859-1
UTF-8 一个汉字占用3个字节
UTF-16

# utf-8编码中的中文占几个字节；int型几个字节

中文3个字节，超大字符集里面的汉字站4个字节，英文一个字节，数字字符 1个，int 4个字节

# 静态代理和动态代理的区别，什么场景使用

代理：给某个对象提供一个代理，并由代理对象控制对象对原对象的引用。

- 静态代理

  是由程序员编写的代理类，并在程序运行前就编译好了，而不是由程序动态产生代理类，这就是静态代理。代理关系在程序运行前就已经确定好的。

  设计模式中的代理模式、装饰器模式。

- 动态代理

  动态代理的实现关键技术是——反射。

  动态代理在程序运行时由 java 反射生成，无需手动实现源代码，可以生成任意类型的动态代理类，提高了软件系统的可扩展性。

  使用场景，比如 retrofit 的 create 方法，就使用了动态代理来统一的处理各个接口。AOP 编程的时候，热修复等。


# Java的异常体系

throwable --> error
          --> Exception --> 运行时异常
                        --> 非运行时异常

- error

  一般是程序无法处理的错误，比如 OOM，ANR 等发生时一般会终止程序。

- 运行时异常

  时程序运行时出现的可以处理的错误，比如空指针等。用try catch finally 来捕获异常并处理

- 非运行时异常
  
  编译期就能发现的异常，如果不处理一般编译不能通过。

# 谈谈你对解析与分派的认识

调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析

解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。

- 静态分派

  所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载（方法相同，参数不同）。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。

- 动态分派

  动态分派与多态性的另一个重要体现——方法覆写（完全相同方法）有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。这种情况很常见，因此这里不再用示例程序进行分析。很显然，在判断执行父类中的方法还是子类中覆盖的方法时，如果用静态类型来判断，那么无论怎么进行向上转型，都只会调用父类中的方法，但实际情况是，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法。 很明显，这里是要根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

# 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法

修改了方法签名后会调用原 equals 方法

```java
if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k)))){

}
```

# Java中实现多态的机制是什么

继承、重写、向上转型。

实现方式：接口和继承

通过继承和重写以及父类引用指向子类对象，在调用的时候通过动态绑定来确定引用对象的最终类型，以确定调用的方法。

# 如何将一个Java对象序列化到文件里

通过实现 Serializable、Parcelable(仅限于android) 或者 Externalizable 接口，通过操作文件流的方式以及ObjectOutputStream.writeObject()来写入。

# 说说你对Java反射的理解

当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载

[参考](http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F)

